# Sunnsteel Backend - Fitness API

Este es el proyecto backend para Sunnsteel, una API de fitness y entrenamiento.

## Stack Tecnológico

- **Framework**: NestJS (Node.js/TypeScript)
- **Base de datos**: PostgreSQL con Prisma ORM
- **Autenticación**: JWT con Passport.js
- **Validación**: class-validator y class-transformer
- **Seguridad**: bcrypt para hash de contraseñas, throttling con @nestjs/throttler
- **Puerto de desarrollo**: 4000 (configurable via PORT env var)

## Estructura del Proyecto

### Módulos Principales

- **AuthModule**: Manejo de autenticación (registro, login, logout, refresh tokens)
- **UsersModule**: Gestión de usuarios y perfiles
- **TokenModule**: Servicios de JWT y refresh tokens
- **DatabaseModule**: Configuración de Prisma y conexión a PostgreSQL
- **ConfigsModule**: Configuraciones del sistema
- **WorkoutsModule**: Sesiones de entrenamiento (iniciar/finalizar), logs de sets, y progresión automática de ejercicios
- **ExercisesModule**: Catálogo de ejercicios disponibles

### Endpoints Disponibles

- **POST /api/auth/register**: Registro de usuarios
- **POST /api/auth/login**: Inicio de sesión
- **POST /api/auth/logout**: Cierre de sesión
- **POST /api/auth/refresh**: Renovación de tokens
- **GET /api/users/profile**: Obtener perfil de usuario (protegido)

#### Routines

- **GET /api/routines**: Listar rutinas del usuario. Filtros opcionales vía query: `isFavorite=true|false`, `isCompleted=true|false`
- **GET /api/routines/favorites**: Listar rutinas favoritas
- **GET /api/routines/completed**: Listar rutinas completadas
- **GET /api/routines/:id**: Obtener una rutina por id
- **POST /api/routines**: Crear rutina
- **PATCH /api/routines/:id**: Actualizar rutina (reemplazo total de días/ejercicios/sets)
- **PATCH /api/routines/:id/favorite**: Marcar/Desmarcar rutina como favorita `{ isFavorite: boolean }`
- **PATCH /api/routines/:id/completed**: Marcar/Desmarcar rutina como completada `{ isCompleted: boolean }`
- **DELETE /api/routines/:id**: Eliminar rutina

#### Workout Sessions

- **GET /api/workouts/sessions**: Listado de sesiones (historial) con filtros, orden y paginación por cursor
  - Query params: `status`, `routineId`, `from`, `to`, `q`, `cursor`, `limit`, `sort`
- **POST /api/workouts/sessions/start**: Iniciar nueva sesión de entrenamiento
- **PATCH /api/workouts/sessions/:id/finish**: Finalizar sesión (aplica progresión automática)
- **GET /api/workouts/sessions/active**: Obtener sesión activa del usuario
- **GET /api/workouts/sessions/:id**: Obtener detalles de sesión específica
- **POST /api/workouts/sessions/:id/sets**: Crear/actualizar log de set
- **DELETE /api/workouts/sessions/:id/sets**: Eliminar log de set

#### Exercises

- **GET /api/exercises**: Listar ejercicios disponibles

## Progresión de Ejercicios

### Esquemas de Progresión

- **DYNAMIC**: Progresión cuando TODOS los sets alcanzan el objetivo de reps
  - Si todos los sets de un ejercicio logran >= reps objetivo, se aumenta el peso en todos los sets
- **DYNAMIC_DOUBLE**: Progresión individual por set
  - Cada set progresa independientemente cuando alcanza el objetivo de reps
- **PROGRAMMED_RTF (Last set Reps to Failure)**: Programa con duración fija y avance por calendario
  - 5 sets por ocurrencia (4 fijos + 1 AMRAP)
  - Intensidad semanal como % del TM; deloads opcionales (W7/14/21 → 3×5 @ RPE6)
  - TM se ajusta 1 vez por semana por ejercicio con la regla pieza a pieza (según reps del AMRAP)
- **Configuración por ejercicio**:
  - `progressionScheme`: `DYNAMIC` | `DYNAMIC_DOUBLE` (default: `DYNAMIC`)
  - `minWeightIncrement`: incremento mínimo de peso (default: `2.5`)

### Aplicación Automática

- Se ejecuta al finalizar una sesión (`PATCH /api/workouts/sessions/:id/finish`)
- Solo para sesiones con status `COMPLETED`
- Actualiza pesos en `RoutineExerciseSet` para próximas sesiones
- Basado en logs de sets (`SetLog`) de la sesión actual

##### Estructura de Sets y Prescripción de Reps

- Soporte de prescripción mediante `repType`:
  - `FIXED` → requiere `reps`
  - `RANGE` → requiere `minReps` y `maxReps` (`minReps <= maxReps`)
- Campos expuestos en selectores de endpoints de rutinas para cada set:
  - `setNumber`, `repType`, `reps`, `minReps`, `maxReps`, `weight`
- Validación en creación/actualización de rutinas asegura consistencia entre `repType` y sus campos asociados.

#### Workouts

- **POST /api/workouts/sessions/start**: Iniciar sesión de entrenamiento para un día de rutina
  - Body: `{ routineId: string, routineDayId: string, notes?: string }`
  - PROGRAMMED_RTF (fecha‑dirigido): valida que hoy esté entre `programStartDate` y `programEndDate`, que hoy sea un día programado y que `routineDay.dayOfWeek` coincida con hoy. La respuesta incluye la prescripción RtF del día por ejercicio.
- **PATCH /api/workouts/sessions/:id/finish**: Finalizar sesión en progreso
  - Body: `{ status: "COMPLETED" | "ABORTED", notes?: string }`
  - PROGRAMMED_RTF: si no es deload, ajusta TM por ejercicio una sola vez por semana usando el AMRAP (set 5); si es deload, TM congelado.
- **GET /api/workouts/sessions/active**: Obtener sesión activa (si existe)
- **GET /api/workouts/sessions**: Listar sesiones (historial) con filtros y paginación por cursor
  - Query: `status?`, `routineId?`, `from?`, `to?`, `q?`, `cursor?`, `limit?`, `sort?`
    - `sort`: `finishedAt:desc|finishedAt:asc|startedAt:desc|startedAt:asc`
    - Validación & coerción (ListSessionsDto):
      - `status` → enum `WorkoutSessionStatus`
      - `routineId`, `cursor` → `@IsUUID()`
      - `from`, `to` → `@IsISO8601()`
      - `limit` → `@Type(() => Number)` + `@IsInt()` + `@Min(1)` + `@Max(50)`
      - `sort` → restringido a valores permitidos con `@IsIn([...])`
- **GET /api/workouts/sessions/:id**: Obtener sesión por id (incluye set logs)
- **PUT /api/workouts/sessions/:id/set-logs**: Upsert de logs de sets durante una sesión
  - Body: `{ routineExerciseId, exerciseId, setNumber, reps?, weight?, rpe?, isCompleted? }`
- **DELETE /api/workouts/sessions/:id/set-logs/:routineExerciseId/:setNumber**: Eliminar un set log específico de la sesión (solo si `IN_PROGRESS`)

### Base de Datos

- **User**: Usuarios con email, password, name
- **RefreshToken**: Tokens de renovación vinculados a usuarios
- **BlacklistedToken**: Tokens de acceso invalidados
- **Routine**: Rutinas de entrenamiento (`isFavorite: Boolean @default(false)`, `isCompleted: Boolean @default(false)`, `isPeriodized`, relación con `RoutineDay`)
  - Campos RtF (programa fecha‑dirigido):
    - `programWithDeloads: Boolean?`, `programDurationWeeks: Int?`
    - `programStartWeek: Int? @default(1)` (solo creación; clamp 1..(18|21))
    - `programStartDate: Date @db.Date?`, `programEndDate: Date @db.Date?`
    - `programTrainingDaysOfWeek: Int[] @default([])`, `programTimezone: String?`
- **WorkoutSession**: Sesión de entrenamiento por usuario y día de rutina (`status: IN_PROGRESS|COMPLETED|ABORTED`, `startedAt`, `endedAt`, `durationSec`, `notes`)
- **SetLog**: Registro de sets ejecutados dentro de una sesión (`reps?`, `weight?`, `rpe?`, `isCompleted`, `completedAt`), único por `(sessionId, routineExerciseId, setNumber)`

##### Modelos Prisma relevantes

```prisma
enum RepType {
  FIXED
  RANGE
}

enum ProgressionScheme {
  NONE
  DOUBLE_PROGRESSION
  DYNAMIC_DOUBLE_PROGRESSION
  PROGRAMMED_RTF
}

model RoutineExerciseSet {
  id                String          @id @default(uuid())
  routineExerciseId String
  routineExercise   RoutineExercise @relation(fields: [routineExerciseId], references: [id], onDelete: Cascade)
  setNumber         Int
  repType           RepType         @default(FIXED)
  reps              Int?
  minReps           Int?
  maxReps           Int?
  weight            Float?

  @@unique([routineExerciseId, setNumber])
}
```

## Configuración

### Variables de Entorno Requeridas

- `DATABASE_URL`: URL de conexión a PostgreSQL
- `JWT_SECRET`: Clave secreta para JWT
- `FRONTEND_URL`: URL del frontend (default: http://localhost:3000)
- `PORT`: Puerto del servidor (default: 4000)

### Características de Seguridad

- CORS configurado para el frontend
- Rate limiting global (100 requests por minuto)
- Validación de DTOs con pipes globales
- Cookies seguras para refresh tokens
- Blacklisting de tokens en logout

## Patrones de Desarrollo

### Autenticación y Autorización

- **JWT Strategy**: Passport JWT para validación de tokens
- **Local Strategy**: Passport Local para login con email/password
- **Guards**: 
  - `passport-jwt.guard.ts`: Guard para validación JWT
  - `passport-local.guard.ts`: Guard para autenticación local
- **Token Management**: Access tokens + refresh tokens
- **Auto-refresh**: Renovación automática de tokens

### Base de Datos

- **Prisma ORM**: Para operaciones de base de datos
- **Migrations**: Control de versiones de esquema
- **Relations**: Relaciones entre User y RefreshToken
- **Transactions**: Para operaciones complejas
- **Indexing**: Optimización de consultas

### API Design

- **RESTful**: Convenciones REST para endpoints
- **DTOs**: Data Transfer Objects para validación
  - `auth.dto.ts`: DTOs para autenticación (login, register)
  - `refresh-token.dto.ts`: DTOs para renovación de tokens
- **Pipes**: Validación global con class-validator
- **Interceptors**: Transformación de respuestas
- **Exception Filters**: Manejo centralizado de errores

### Seguridad

- **Password Hashing**: bcrypt para contraseñas
- **Rate Limiting**: Throttler para prevenir abuso
- **CORS**: Configuración específica para frontend
- **Token Blacklisting**: Invalidación de tokens
- **Input Validation**: Validación robusta de datos

## Integración con Frontend

### CORS Configuration

- Origin: http://localhost:3000 (frontend)
- Credentials: true (para cookies)
- Methods: GET, POST, PUT, DELETE, PATCH

### Authentication Flow

1. Register/Login → Access token en response
2. Refresh token en cookies (httpOnly, secure)
3. Auto-refresh cuando access token expira
4. Logout → Blacklist tokens y clear cookies

### Response Format

```typescript
{
  user: { id, email, name },
  accessToken: string
}
```

## Patrones de Código

### Imports y Estructura

- **Services**: Lógica de negocio
- **Controllers**: Manejo de requests/responses
- **DTOs**: Validación de datos
- **Guards**: Protección de rutas
- **Interceptors**: Transformación de datos

### Convenciones

- **Services**: camelCase con sufijo "Service"
- **Controllers**: PascalCase con sufijo "Controller"
- **DTOs**: PascalCase con sufijo "Dto"
- **Guards**: PascalCase con sufijo "Guard"
- **Types**: PascalCase con sufijo "Type"

### Manejo de Errores

- **HTTP Exceptions**: NestJS built-in exceptions
- **Custom Exceptions**: Para errores específicos del dominio
- **Exception Filters**: Manejo centralizado
- **Logging**: Para debugging y monitoreo

## Contexto para el Agente

Cuando implementes funcionalidades:

- Usa decoradores de NestJS (@Controller, @Service, @Injectable)
- Implementa autenticación con JWT y Passport
- Sigue patrones de Prisma para base de datos
- Valida datos con DTOs y class-validator
- Maneja errores de forma consistente
- Implementa seguridad con guards e interceptors
- Usa TypeScript con tipos estrictos
- Sigue convenciones REST para APIs
- Integra con el frontend de forma segura
  description:
  globs:
  alwaysApply: false

---
